# Parallel-Linear-Algebra
[Более подробное описание задачи](https://github.com/Raincwail/Parallel-Linear-Algebra/blob/master/task.pdf)

## 2. Релизовать алгоритм матричного умножения с разбиением на блоки по алгоритму Кэннона.

### Описание задачи

На вход подаются матрицы $A$ и $B$, а также число процессов $procNum$. В качестве результат алгоритм выдает матрицу $C = A * B$.

Ограничения:
* $A$ и $B$ квадратные матрицы
* $procNum$ должен быть квадратом какого-либо числа
* Корень $procNum$ должен быть делителем размера матриц

### Решение задачи

Алгоритм представляет из себя разделение матриц на блоки в соответствии с количество блоков для последующего перемножения соответствующих блоков.

Предположим, что матрицы можно разделить на 4 блока, тогда процессы будут распологаться следующим образом:
<div align="center"><table>
<tr><th> Матрица А </th><th> Матрица B </th></tr>
<tr><td>

| P00(A) | P01(A) |
|--|--|
| P10(A)| P11(A) |

</td><td>

| P00(B) | P01(B) |
|--|--|
| P10(B)| P11(B) |

</td></tr> </table> </div>

Затем каждый процесс вычисляет свою часть $C$, например, $C00 = P00(A) * P00(B)$.

Далее производятся сдвиги: матрица $A$ сдвигается влево, матрица $B$ сдвигается вверх.

<div align="center"><table>
<tr><th> Матрица А </th><th> Матрица B </th></tr>
<tr><td>

| P01(A) | P00(A) |
|--|--|
| P11(A)| P10(A) |

</td><td>

| P10(B) | P11(B) |
|--|--|
| P00(B)| P01(B) |

</td></tr> </table> </div>

Вновь высчитывается произведение, но на этот раз результат прибавляется к существующему, т.е. $C00 += P01(A) * P10(B)$.

Операция повторяется $sqrt(procNum)$ раз.

Полная реализация алгоритма, включая установку матриц, находится в [main](https://github.com/Raincwail/Parallel-Linear-Algebra/blob/master/CANNON-MPI/main.c).

### Оценка качества

В качестве оценки качества решения были проведены следующие эксперименты и получены соответствующие результаты (мс).

| Размер Матрицы / Версия Решения | 1024x1024 | 2048x2048 | 4096x4096 |
| ------------- | ------------- | ------------- | ------------- |
| Параллельная версия (1 поток) | 4302 | 121618 | 1107304 |
| Параллельная версия (4 потока) | 1449 | 18542 | 337624 |
| Параллельная версия (16 потоков) | 989 | 8760 | 115023 |
| Параллельная версия (64 потока) | 1615 | 8995 | 69960 |

Более наглядные графики, а также таблицы анализа ускорения и эффективности можно найти в ноутбуке [analysis](https://github.com/Raincwail/Parallel-Linear-Algebra/blob/master/CANNON-MPI/analysis.ipynb).

## 3.  С использованием CUDA решить СЛАУ прямым (Гаусс) или итерационным методом (CG, сопряженные градиенты).

### Описание задачи

На вход подается симметричная, положительно определенная матрица $A$ и вектор $b$, в качестве результат алгоритм выдает решение СЛАУ $Ax = b$.

Алгоритм представляет из себя итеративный градиентный спуск с минимизацией  $\phi(x) = \frac{1}{2}x^T A x - x^T b$.

### Решение задачи

В качестве решения были реализованы [итеративная](https://github.com/Raincwail/Parallel-Linear-Algebra/tree/master/CG-CUDA/iterative) и [параллельная](https://github.com/Raincwail/Parallel-Linear-Algebra/tree/master/CG-CUDA/parallel) версии.

Для установки матрицы $A$ и вектора $b$ используется заголовок [Base](https://github.com/Raincwail/Parallel-Linear-Algebra/blob/master/CG-CUDA/Base.h).

Основное отличие заключается в использованных векторных операциях - итеративная версия использует наивные имплементации, в то время как параллельная использует инструменты CUDA для ускорения вычислений.

### Оценка качества

В качестве оценки качества решения были проведены следующие эксперименты и получены соответствующие результаты (мс).

| Размер Матрицы / Версия Решения | 512x512 | 1024x1024 | 2048x2048 | 4096x4096 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| Итеративная версия | 639 | 2518 | 9892 | 38988 |
| Параллельная версия (16 потоков) | 89 | 194 | 548 | 1470 |
| Параллельная версия (32 потока) | 77 | 149 | 325 | 752 |
| Параллельная версия (64 потока) | 92 | 127 | 307 | 745 |

Для замеров времени использовались [Timer](https://github.com/Raincwail/Parallel-Linear-Algebra/blob/master/CG-CUDA/iterative/Timer.h) и [GpuTimer](https://github.com/Raincwail/Parallel-Linear-Algebra/blob/master/CG-CUDA/parallel/GpuTimer.cuh) соответственно.

Более наглядные графики, а также таблицы анализа ускорения и эффективности можно найти в ноутбуке [analysis](https://github.com/Raincwail/Parallel-Linear-Algebra/blob/master/CG-CUDA/analysis.ipynb).
